/**
 * @fileOverview cubic bezier timeout
 * @see http://xlo.co/javascript-bezier-easing
 */
'use strict';

function getSplineValue(aX, mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2) return aX;

  function a(aA1,aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }
  function b(aA1,aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }
  function c(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT,aA1,aA2) {
    // use Horner's scheme to evaluate the Bezier polynomial
    return ((a(aA1, aA2)*aT + b(aA1, aA2))*aT + c(aA1))*aT;
  }

  function getSlope(aT,aA1,aA2) {
    return 3.0 * a(aA1, aA2)*aT*aT + 2.0 * b(aA1, aA2) * aT + c(aA1);
  }

  function getTForX(aX) {
    var initialSlope = getSlope(aX, mX1, mX2);
    if (initialSlope < 0.02) {
      throw new Error('Slope is less than 0.02');
    }
    return newtonRaphsonIterate(aX);
  }

  function newtonRaphsonIterate(aX) {
    var aGuessT = aX;
    // Refine guess with Newton-Raphson iteration
    for (var i = 0; i < 3; ++i) {
      // We're trying to find where f(t) = aX,
      // so we're actually looking for a root for: calcBezier(t) - aX
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) return aGuessT;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }
  return calcBezier(getTForX(aX), mY1, mY2);
}

/**
 * Call your callback with a sequence of intervals
 * like using CSS3 cubic-bezier-timeout
 * @param  {object} options
 *         - callback   function the function you want to be called every timeout
 *         - count      number   how many calls do you want
 *         - duration   number   how much time does it consume in ms
 *         - points     object   cubic bezier points
 *           - x1
 *           - y1
 *           - x2
 *           - y2
 * @param  {function} done        this will be called when all timeouts are done
 *         - delay      number    with parameter of last timeout value
 * @return {number}     the timer generated by setTimeout, you can cancel it
 *                      by clearTimeout
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  }
  else if (typeof exports === 'object') {
    module.exports = factory();
  }
  else {
    root.returnExports = factory();
  }
}(this, function () {
  return function cubicBezierTimeout(options, done) {
    options = options || {};
    var callback = options.callback;
    if (typeof callback !== 'function') {
      return null;
    }

    var count = options.count || 10;
    var duration = options.duration || 1000;
    var points = options.points;
    var x1 = points.x1 || 0;
    var y1 = points.y1 || 0;
    var x2 = points.x2 || 0;
    var y2 = points.y2 || 0;

    var step = (duration / count) / 1000;
    var delay = 0;
    var timer;
    var t = 0;
    var delta;

    var timeout = function() {
      t += step;
      if (t < 1) {
        callback();

        var newDelay = getSplineValue(t, x1, y1, x2, y2) * duration;
        delta = Math.max(newDelay - delay, 0);

        timer = setTimeout(function() {
          timeout();
        }, delta);

        delay = newDelay;
      }
      else if (typeof done === 'function') {
        done(delta);
      }
    };

    timeout();
    return timer;
  };
}));
